# è¿‘æœŸæ–¹æ¡ˆ (v0.5.0) - CLIæ¥å£ä¸å¤šè¡¨æ”¯æŒæ¼”è¿›

## 1. å¼•è¨€

æœ¬æ–‡æ¡£æ—¨åœ¨ä¸ºã€Šè¿‘æœŸè®¡åˆ’çš„éœ€æ±‚.mdã€‹ä¸­å®šä¹‰çš„ç›®æ ‡æä¾›å…·ä½“çš„æŠ€æœ¯æ–¹æ¡ˆä¸è®¾è®¡æ€è·¯ã€‚

æ‰€æœ‰æ–¹æ¡ˆéƒ½å°†ä¸¥æ ¼éµå¾ª `notes/Design_Schema_Validation_Command.md` ä¸­é˜è¿°çš„æ ¸å¿ƒæ¶æ„ï¼Œå³ï¼š**CLIå±‚è´Ÿè´£è§£æå’Œåˆ†è§£ç”¨æˆ·è¾“å…¥ï¼Œç”ŸæˆåŸå­åŒ–çš„è§„åˆ™å¯¹è±¡ï¼›Coreå±‚è´Ÿè´£æ‰§è¡Œè¿™äº›åŸå­è§„åˆ™**ã€‚æœ¬æ¬¡é‡æ„çš„æ ¸å¿ƒæ˜¯å°†å˜æ›´æ§åˆ¶åœ¨CLIå±‚ï¼Œä»¥è¯æ˜ç°æœ‰æ¶æ„çš„å¥å£®æ€§å’Œå¯æ‰©å±•æ€§ã€‚

---

## 2. `check` å‘½ä»¤æ¥å£é‡æ„æ–¹æ¡ˆ âœ… å·²å®Œæˆ

*   **ç›®æ ‡**: å°†æ¥å£ä» `vlite-cli check <data_source>` æ¨¡å¼é‡æ„ä¸º `vlite-cli check --conn <string> --table <string>` æ¨¡å¼ã€‚
*   **å½±å“æ¨¡å—**: `cli/app.py`, `cli/commands/check.py`ã€‚
*   **é‡æ„ç­–ç•¥**: ç›´æ¥æ›¿æ¢æ—§æ¥å£ï¼Œä¸ä¿ç•™å‘åå…¼å®¹æ€§ã€‚
*   **çŠ¶æ€**: âœ… å·²å®Œæˆ - æ–°æ¥å£å·²å®ç°å¹¶æ­£å¸¸å·¥ä½œ

### 2.1. æ–°æ¥å£è®¾è®¡

```python
# ä½äº cli/commands/check.py

@click.command("check")
@click.option(
    "--conn",
    "connection_string",
    required=True,
    help="Database connection string or file path"
)
@click.option(
    "--table",
    "table_name", 
    required=True,
    help="Table name to validate"
)
@click.option(
    "--rule",
    "rules",
    multiple=True,
    help="Inline rule expression (can be used multiple times)"
)
@click.option(
    "--rules",
    "rules_file",
    type=click.Path(exists=True, readable=True),
    help="Path to rules file (JSON format)"
)
@click.option("--quiet", is_flag=True, default=False, help="Show summary only")
@click.option(
    "--verbose",
    is_flag=True,
    default=False,
    help="Show detailed information and failure samples"
)
def check_command(
    connection_string: str,
    table_name: str,
    rules: Tuple[str, ...],
    rules_file: Optional[str],
    quiet: bool,
    verbose: bool,
) -> None:
    """
    Check data quality for the given source.
    
    NEW FORMAT:
        vlite-cli check --conn <connection> --table <table_name> [options]
    
    SOURCE can be:
    - File path: users.csv, data.xlsx, records.json
    - Database URL: mysql://user:pass@host/db
    - SQLite file: sqlite:///path/to/file.db

    Examples:
        vlite-cli check --conn users.csv --table users --rule "not_null(id)"
        vlite-cli check --conn mysql://user:pass@host/db --table users --rules validation.json
    """
    # Record start time
    start_time = now()
    logger.info(f"Starting data quality check for: {connection_string}")

    # Create exception handler
    exception_handler = CliExceptionHandler(verbose=verbose)

    # Initialize error variables
    cli_error = None
    schema_error = None
    engine_error = None
    results = None

    try:
        # Phase 1: CLI self-processing and Schema creation
        try:
            # Load configurations using new system
            core_config = get_core_config()
            cli_config = get_cli_config()

            # Initialize components
            source_parser = SourceParser()
            rule_parser = RuleParser()
            output_formatter = OutputFormatter(quiet=quiet, verbose=verbose)

            # Validate inputs
            if not rules and not rules_file:
                raise click.UsageError(
                    "No rules specified. Use --rule for inline rules or "
                    "--rules for rules file."
                )

            # Parse source
            safe_echo(f"ğŸ” Analyzing source: {connection_string}")

            # Proactively verify that a provided file is not empty
            potential_path = Path(connection_string)
            if potential_path.exists() and potential_path.is_file():
                if potential_path.stat().st_size == 0:
                    raise click.ClickException(
                        f"Error: Source file '{connection_string}' is empty "
                        "â€“ nothing to validate."
                    )

            # Parse source config
            source_config = source_parser.parse_source(connection_string)

            # Parse rules
            safe_echo("ğŸ“‹ Loading validation rules...")
            rule_configs = rule_parser.parse_rules(
                inline_rules=list(rules) if rules else [], rules_file=rules_file
            )

            if not rule_configs:
                raise click.UsageError("No valid rules found.")

            safe_echo(f"   Found {len(rule_configs)} validation rules")

            # Create data validator
            validator = DataValidator(
                source_config=source_config,
                rules=cast(list, rule_configs),
                core_config=core_config,
                cli_config=cli_config,
            )
        except (OperationError, RuleExecutionError) as e:
            schema_error = e
            raise
        except Exception as e:
            cli_error = e
            raise

        # Phase 2: Core validation execution
        try:
            # Execute validation
            safe_echo("âœ… Starting validation...")
            results = asyncio.run(validator.validate())
            results_dicts = (
                [r.model_dump() for r in results] if results is not None else []
            )
        except EngineError as e:
            engine_error = e
            raise
        logger.info(f"Results: {results}")

        # Phase 3: Result processing
        error_context = exception_handler.handle_complete_process(
            cli_error=cli_error,
            schema_error=schema_error,
            engine_error=engine_error,
            results=results,
        )

        # Decide output and exit code based on error context
        if error_context.category != "success":
            # Show error message
            safe_echo(f"âŒ {error_context.user_message}", err=True)

            # Show recovery suggestions
            if error_context.recovery_actions:
                safe_echo("\nSuggested actions:")
                for action in error_context.recovery_actions:
                    safe_echo(f"â€¢ {action}")

            # Show technical details (if verbose enabled)
            if verbose and error_context.technical_details:
                safe_echo(f"\nTechnical details:\n{error_context.technical_details}")

            sys.exit(error_context.exit_code)
        else:
            # On success, calculate execution time and display results
            end_time = now()
            execution_time = (end_time - start_time).total_seconds()

            # Format and display results
            output_formatter.display_results(
                results=results_dicts,
                rules=rule_configs,
                source=connection_string,
                execution_time=execution_time,
                total_rules=len(rule_configs),
            )

            # Set exit code based on validation results
            has_failures = any(result["status"] == "FAILED" for result in results_dicts)

            if has_failures:
                logger.warning("Validation completed with failures")
                sys.exit(1)
            else:
                logger.info("All validations passed successfully")
                safe_echo(f"âœ… {error_context.user_message}")
                sys.exit(0)

    except click.UsageError:
        raise

    except Exception as e:
        # Unified error handling
        if isinstance(e, EngineError):
            engine_error = e

        error_context = exception_handler.handle_complete_process(
            cli_error=cli_error,
            schema_error=schema_error,
            engine_error=engine_error,
            results=results,
        )

        if error_context.category == "success":
            # On success, calculate execution time and display results
            end_time = now()
            execution_time = (end_time - start_time).total_seconds()

            # Format and display results
            output_formatter.display_results(
                results=results_dicts,
                rules=rule_configs,
                source=connection_string,
                execution_time=execution_time,
                total_rules=len(rule_configs),
            )

            # Show success message
            safe_echo(f"âœ… {error_context.user_message}")
            sys.exit(0)
        else:
            # Show error message
            safe_echo(f"âŒ {error_context.user_message}", err=True)

            if error_context.recovery_actions:
                safe_echo("\nSuggested actions:")
                for action in error_context.recovery_actions:
                    safe_echo(f"â€¢ {action}")

            if verbose and error_context.technical_details:
                safe_echo(f"\nTechnical details:\n{error_context.technical_details}")

            sys.exit(error_context.exit_code)
```

### 2.2. æ¥å£å˜æ›´è¯´æ˜

*   **ç§»é™¤ä½ç½®å‚æ•°**: ä¸å†æ”¯æŒ `<source>` ä½ç½®å‚æ•°
*   **å¼ºåˆ¶æ–°é€‰é¡¹**: `--conn` å’Œ `--table` éƒ½æ˜¯å¿…éœ€çš„é€‰é¡¹
*   **ç®€åŒ–é€»è¾‘**: ä¸å†éœ€è¦å‚æ•°éªŒè¯å’Œå‘åå…¼å®¹æ€§å¤„ç†
*   **æ¸…æ™°è¯­ä¹‰**: æ–°æ¥å£æ›´åŠ æ˜ç¡®å’Œç›´è§‚

---

## 3. `schema` å‘½ä»¤å¤šè¡¨æ”¯æŒæ–¹æ¡ˆ ğŸ”„ å¾…å®ç°

*   **ç›®æ ‡**: ä½¿ `schema` å‘½ä»¤èƒ½å¤Ÿé€šè¿‡å•ä¸ªè§„åˆ™æ–‡ä»¶ï¼ŒéªŒè¯ä¸€ä¸ªæ•°æ®æºä¸­çš„å¤šä¸ªè¡¨ã€‚
*   **å½±å“æ¨¡å—**: `cli/commands/schema.py`ã€‚
*   **çŠ¶æ€**: ğŸ”„ å¾…å®ç° - å½“å‰åªæ”¯æŒå•è¡¨éªŒè¯ï¼Œéœ€è¦æ‰©å±•ä¸ºå¤šè¡¨æ”¯æŒ

### 3.1. CLI æ¥å£å˜æ›´

*   **å‘½ä»¤æ ¼å¼**: `vlite-cli schema --conn <connection_string> --rules <multi_table_schema.json>`
*   **è¯´æ˜**: ç§»é™¤ `<data_source>` ä½ç½®å‚æ•°ï¼Œå¼•å…¥ `--conn` é€‰é¡¹ã€‚**éœ€è¦ç§»é™¤ `--table` é€‰é¡¹**ï¼Œå› ä¸ºæ‰€æœ‰ç›®æ ‡è¡¨å°†åœ¨è§„åˆ™æ–‡ä»¶ä¸­å®šä¹‰ã€‚
*   **å½“å‰çŠ¶æ€**: âŒ ä»éœ€è¦ `--table` å‚æ•°ï¼Œæ¥å£æœªå®Œå…¨æ›´æ–°

### 3.2. `--rules` æ–‡ä»¶æ ¼å¼æ¼”è¿›

*   **æ–°æ ¼å¼**: é‡‡ç”¨ä»¥**è¡¨åä¸ºé”®**çš„é¡¶å±‚JSONå¯¹è±¡ï¼Œå…¶å€¼æ˜¯åŸå…ˆä¸ºå•è¡¨è®¾è®¡çš„schemaå®šä¹‰ã€‚
*   **ç¤ºä¾‹ `multi_table_schema.json`**:
    ```json
    {
      "users": {
        "rules": [
          { "field": "id", "type": "integer", "required": true },
          { "field": "email", "type": "string" }
        ],
        "strict_mode": true
      },
      "products": {
        "rules": [
          { "field": "product_id", "type": "integer" },
          { "field": "price", "type": "float" }
        ]
      }
    }
    ```
*   **å½“å‰çŠ¶æ€**: âŒ ä»£ç ä¸­æ˜ç¡®æ‹’ç»å¤šè¡¨æ ¼å¼ï¼Œéœ€è¦ç§»é™¤é™åˆ¶å¹¶å®ç°è§£æé€»è¾‘

### 3.3. CLI åˆ†è§£é€»è¾‘å˜æ›´ (æ ¸å¿ƒè®¾è®¡)

`schema` å‘½ä»¤çš„CLIå±‚å°†å¢åŠ ä¸€ä¸ª**å¤–å±‚å¾ªç¯**æ¥éå†å¤šè¡¨è§„åˆ™æ–‡ä»¶ï¼Œè€Œå†…å±‚çš„åˆ†è§£é€»è¾‘å®Œå…¨å¤ç”¨ `Design_Schema_Validation_Command.md` ä¸­å·²å®šä¹‰çš„å•è¡¨åˆ†è§£é€»è¾‘ã€‚

**å½“å‰çŠ¶æ€**: âŒ åªæœ‰å•è¡¨åˆ†è§£é€»è¾‘ `_decompose_to_atomic_rules`ï¼Œéœ€è¦æ‰©å±•ä¸ºå¤šè¡¨æ”¯æŒ

*   **ä¼ªä»£ç è®¾è®¡**:

    ```python
    # ä½äº cli/commands/schema.py

    def handle_schema_command(conn_str: str, rules_path: Path):
        """å¤„ç†schemaå‘½ä»¤çš„æ‰§è¡Œ"""

        multi_table_schema = load_json(rules_path)
        all_atomic_rules = []
        database = parse_database_from_conn(conn_str)

        # 1. **æ–°å¢æ ¸å¿ƒé€»è¾‘**: éå†åœ¨ --rules æ–‡ä»¶ä¸­å®šä¹‰çš„æ‰€æœ‰è¡¨
        for table_name, single_table_schema in multi_table_schema.items():
            
            # 2. **å¤ç”¨ç°æœ‰è®¾è®¡**: å¯¹æ¯ä¸ªè¡¨ï¼Œè°ƒç”¨å·²æœ‰çš„å•è¡¨åˆ†è§£é€»è¾‘
            #    è¯¥é€»è¾‘éµå¾ª Design_Schema_Validation_Command.md ä¸­çš„å®šä¹‰ï¼Œ
            #    å°†å•ä¸ªè¡¨çš„schemaåˆ†è§£ä¸ºä¸€ç³»åˆ—åŸå­çš„ NotNullRule, RangeRule, EnumRuleç­‰ã€‚
            #    æˆ‘ä»¬åœ¨è¿™é‡Œå°è£…ä¸€ä¸ªè¾…åŠ©å‡½æ•°æ¥ä½“ç°ã€‚
            atomic_rules_for_table = decompose_single_table_schema(
                database=database,
                table_name=table_name,
                table_schema_def=single_table_schema
            )
            all_atomic_rules.extend(atomic_rules_for_table)

        # 3. è°ƒç”¨Core Engineï¼Œä¼ å…¥åŒ…å«æ‰€æœ‰è¡¨çš„æ‰€æœ‰åŸå­è§„åˆ™çš„åˆ—è¡¨
        results = core_engine.execute(all_atomic_rules, connection_string=conn_str)

        # 4. èšåˆä¸æ¸²æŸ“ç»“æœï¼ŒæŒ‰è¡¨è¿›è¡Œåˆ†ç»„
        render_multi_table_results(results)


    def decompose_single_table_schema(database, table_name, table_schema_def) -> list:
        """
        æ­¤è¾…åŠ©å‡½æ•°çš„é€»è¾‘ä¸¥æ ¼éµå¾ª Design_Schema_Validation_Command.mdã€‚
        å®ƒå°†å•è¡¨çš„schemaå®šä¹‰åˆ†è§£ä¸ºåŸå­è§„åˆ™åˆ—è¡¨ã€‚
        """
        decomposed_rules = []
        rules_list = table_schema_def.get("rules", [])

        for field_def in rules_list:
            # åˆ›å»º RuleTarget
            target = RuleTarget(database=database, table=table_name, column=field_def["field"])

            # a. åˆ†è§£å‡º NotNullRule
            if field_def.get("required"): 
                decomposed_rules.append(NotNullRule(target=target))

            # b. åˆ†è§£å‡º EnumRule
            if "enum" in field_def:
                decomposed_rules.append(EnumRule(target=target, params={"allowed_values": field_def["enum"]}))
            
            # c. ... å…¶ä»–ç±»å‹çš„è§„åˆ™åˆ†è§£ (Range, etc.)

        # d. è¿˜å¯ä»¥åˆ›å»ºä¸€ä¸ªæ•´ä½“çš„ã€æ£€æŸ¥æ‰€æœ‰å­—æ®µç±»å‹å’Œå­˜åœ¨æ€§çš„ table-level SCHEMA è§„åˆ™
        #    (éµå¾ªè®¾è®¡æ–‡æ¡£ä¸­çš„ SchemaRule å®šä¹‰)
        # decomposed_rules.append(TableSchemaRule(target=..., params=...))

        return decomposed_rules

    ```

### 3.4. å¯¹CoreåŠSharedæ¨¡å—çš„å½±å“

*   **æ— å½±å“**ã€‚è¿™æ˜¯æ­¤æ–¹æ¡ˆæœ€å¤§çš„ä¼˜ç‚¹ã€‚Coreå±‚çš„ `Rule` æ¥å£ã€å„ç§åŸå­è§„åˆ™çš„å®ç°ã€ä»¥åŠ `core_engine` çš„æ‰§è¡Œé€»è¾‘å®Œå…¨ä¸éœ€è¦æ”¹å˜ã€‚`RuleTarget` å¯¹è±¡ä¸­å·²ç»åŒ…å«äº†è¡¨åï¼Œå› æ­¤Coreå¤©ç”Ÿå°±èƒ½å¤„ç†æ¥è‡ªä¸åŒè¡¨çš„è§„åˆ™ã€‚æ‰€æœ‰å˜æ›´éƒ½è¢«ä¼˜é›…åœ°é™åˆ¶åœ¨äº†CLIå±‚ã€‚
*   **çŠ¶æ€**: âœ… ç¡®è®¤æ— å½±å“ - Coreå±‚æ¶æ„è®¾è®¡è‰¯å¥½ï¼Œæ”¯æŒå¤šè¡¨è§„åˆ™

### 3.5. æ–‡ä»¶å‹æ•°æ®æºçš„å¤šè¡¨æ”¯æŒæ–¹æ¡ˆ (æ–°å¢)

*   **èƒŒæ™¯**: åœ¨æµ‹è¯•å¤šè¡¨schemaéªŒè¯åŠŸèƒ½æ—¶ï¼ŒCSVç­‰æ–‡ä»¶æ ¼å¼æœ¬è´¨ä¸ŠåªåŒ…å«ä¸€ä¸ªæ•°æ®é›†ï¼Œéš¾ä»¥æ¨¡æ‹Ÿå¤šè¡¨åœºæ™¯ã€‚
*   **è§£å†³æ–¹æ¡ˆ**: å¢å¼º `SourceParser` çš„èƒ½åŠ›ï¼Œä½¿å…¶èƒ½å¤Ÿå°†**å•ä¸ªExcelæ–‡ä»¶ä½œä¸ºå¤šè¡¨æ•°æ®æº**è¿›è¡Œå¤„ç†ã€‚
    *   å½“ `--conn` å‚æ•°æŒ‡å‘ä¸€ä¸ªExcelæ–‡ä»¶ (`.xlsx`, `.xls`) æ—¶ï¼Œç¨‹åºä¼šè¯»å–è¯¥æ–‡ä»¶çš„æ‰€æœ‰å·¥ä½œè¡¨ (sheets)ã€‚
    *   æ¯ä¸€ä¸ª**å·¥ä½œè¡¨ (sheet) éƒ½è¢«è§†ä¸ºä¸€ä¸ªç‹¬ç«‹çš„è¡¨**ã€‚
    *   å·¥ä½œè¡¨çš„**åç§° (sheet name) å°†è¢«ç”¨ä½œè¡¨å (`table_name`)**ã€‚
*   **æ‰§è¡Œæµç¨‹ç¤ºä¾‹**:
    1.  ç”¨æˆ·æä¾› `--conn data.xlsx` å’Œ `--rules rules.json`ã€‚
    2.  `SourceParser` è§£æ `data.xlsx`ï¼Œå‘ç°å…¶ä¸­åŒ…å«åä¸º `users` å’Œ `products` çš„ä¸¤ä¸ªsheetã€‚
    3.  `schema` å‘½ä»¤çš„åˆ†è§£é€»è¾‘è¯»å– `rules.json`ï¼Œå‘ç°å…¶ä¸­ä¹Ÿå®šä¹‰äº† `users` å’Œ `products` ä¸¤ä¸ªè¡¨çš„è§„åˆ™ã€‚
    4.  å‘½ä»¤å¼€å§‹æ‰§è¡Œï¼Œå®ƒä¼šç”¨ `users` è¡¨çš„è§„åˆ™å»éªŒè¯ `data.xlsx` ä¸­ `users` sheetçš„æ•°æ®ï¼Œç”¨ `products` è¡¨çš„è§„åˆ™å»éªŒè¯ `products` sheetçš„æ•°æ®ã€‚
*   **å½±å“æ¨¡å—**: `cli/core/source_parser.py` (æˆ–å¤„ç†æ•°æ®æºè§£æçš„ç›¸å…³æ¨¡å—)ã€‚

---

## 4. æµ‹è¯•ç­–ç•¥

### 4.1. æ–°æ¥å£æµ‹è¯• âœ… å·²å®Œæˆ
*   æµ‹è¯• `--conn` å’Œ `--table` é€‰é¡¹æ­£å¸¸å·¥ä½œ
*   æµ‹è¯•å‚æ•°éªŒè¯é€»è¾‘
*   æµ‹è¯•å¿…éœ€å‚æ•°ç¼ºå¤±æ—¶çš„é”™è¯¯å¤„ç†
*   **çŠ¶æ€**: âœ… å·²å®Œæˆ - checkå‘½ä»¤çš„æ–°æ¥å£æµ‹è¯•å·²è¦†ç›–

### 4.2. åŠŸèƒ½æµ‹è¯• ğŸ”„ éƒ¨åˆ†å®Œæˆ
*   ç¡®ä¿æ‰€æœ‰ç°æœ‰åŠŸèƒ½åœ¨æ–°æ¥å£ä¸‹æ­£å¸¸å·¥ä½œ
*   æµ‹è¯•æ–‡ä»¶è·¯å¾„ã€æ•°æ®åº“è¿æ¥ç­‰ä¸åŒæ•°æ®æº
*   æµ‹è¯•å†…è”è§„åˆ™å’Œè§„åˆ™æ–‡ä»¶
*   **çŠ¶æ€**: ğŸ”„ éƒ¨åˆ†å®Œæˆ - checkå‘½ä»¤å·²æµ‹è¯•ï¼Œschemaå‘½ä»¤çš„å¤šè¡¨åŠŸèƒ½å¾…æµ‹è¯•

### 4.3. ç°æœ‰æµ‹è¯•æ›´æ–° ğŸ”„ éƒ¨åˆ†å®Œæˆ
*   æ›´æ–°æ‰€æœ‰ç°æœ‰æµ‹è¯•ä»¥ä½¿ç”¨æ–°æ¥å£
*   ä¿æŒæµ‹è¯•è¦†ç›–ç‡åœ¨80%ä»¥ä¸Š
*   ç§»é™¤å¯¹æ—§æ¥å£çš„æµ‹è¯•
*   **çŠ¶æ€**: ğŸ”„ éƒ¨åˆ†å®Œæˆ - checkå‘½ä»¤æµ‹è¯•å·²æ›´æ–°ï¼Œschemaå‘½ä»¤æµ‹è¯•å¾…åˆ›å»º

---

## 5. æ€»ç»“

è¯¥æ–¹æ¡ˆé€šè¿‡åœ¨CLIå±‚è¿›è¡Œæ¥å£é‡æ„ï¼Œå®ç°äº†å¯¹å¤šè¡¨éªŒè¯çš„æ”¯æŒï¼ŒåŒæ—¶ä¿æŒäº†æ ¸å¿ƒå¼•æ“çš„ç¨³å®šã€‚è¿™å……åˆ†åˆ©ç”¨äº†ç°æœ‰è®¾è®¡çš„æ‰©å±•æ€§ï¼Œæ˜¯ä¸€ä¸ªä½é£é™©ã€é«˜æ”¶ç›Šçš„æ¼”è¿›è·¯å¾„ã€‚

**å½“å‰è¿›å±•**:
- âœ… **checkå‘½ä»¤é‡æ„**: å·²å®Œæˆï¼Œæ–°æ¥å£æ­£å¸¸å·¥ä½œ
- ğŸ”„ **schemaå‘½ä»¤å¤šè¡¨æ”¯æŒ**: å¾…å®ç°ï¼Œéœ€è¦æ‰©å±•æ¥å£å’Œè§£æé€»è¾‘
- âœ… **Coreå±‚æ¶æ„**: ç¡®è®¤æ— å½±å“ï¼Œè®¾è®¡è‰¯å¥½

**å…³é”®ä¼˜åŠ¿**:
1. **æ¸…æ™°æ¥å£**: æ–°çš„ `--conn` å’Œ `--table` é€‰é¡¹è¯­ä¹‰æ›´åŠ æ˜ç¡®
2. **ç®€åŒ–é€»è¾‘**: ç§»é™¤äº†å¤æ‚çš„å‘åå…¼å®¹æ€§å¤„ç†
3. **æ¶æ„ç¨³å®š**: Coreå±‚å®Œå…¨ä¸å—å½±å“
4. **æ˜“äºç»´æŠ¤**: ä»£ç ç»“æ„æ›´åŠ æ¸…æ™°ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤

**ä¸‹ä¸€æ­¥å·¥ä½œ**:
1. å®ç°schemaå‘½ä»¤çš„å¤šè¡¨æ”¯æŒ
2. ç§»é™¤ `--table` é€‰é¡¹è¦æ±‚
3. æ”¯æŒå¤šè¡¨è§„åˆ™æ–‡ä»¶æ ¼å¼
4. æ·»åŠ ç›¸åº”çš„æµ‹è¯•è¦†ç›–

---

## 6. è¯¦ç»†å®æ–½è®¡åˆ’

### 6.1. Schemaå‘½ä»¤å¤šè¡¨æ”¯æŒå®ç°æ­¥éª¤

#### æ­¥éª¤1: æ›´æ–°CLIæ¥å£
- [ ] ç§»é™¤ `--table` é€‰é¡¹å‚æ•°
- [ ] æ›´æ–°å‡½æ•°ç­¾åï¼Œç§»é™¤ `table_name` å‚æ•°
- [ ] æ›´æ–°å¸®åŠ©æ–‡æ¡£å’Œç¤ºä¾‹

#### æ­¥éª¤2: å®ç°å¤šè¡¨è§„åˆ™æ–‡ä»¶è§£æ
- [ ] ç§»é™¤å¯¹ `"tables"` å­—æ®µçš„æ‹’ç»é€»è¾‘
- [ ] å®ç°å¤šè¡¨JSONæ ¼å¼çš„è§£æ
- [ ] éªŒè¯æ¯ä¸ªè¡¨çš„è§„åˆ™ç»“æ„

#### æ­¥éª¤3: æ‰©å±•è§„åˆ™åˆ†è§£é€»è¾‘
- [ ] åˆ›å»º `_decompose_multi_table_schema` å‡½æ•°
- [ ] å®ç°å¤–å±‚å¾ªç¯éå†æ‰€æœ‰è¡¨
- [ ] å¤ç”¨ç°æœ‰çš„å•è¡¨åˆ†è§£é€»è¾‘
- [ ] ä¸ºæ¯ä¸ªè¡¨è®¾ç½®æ­£ç¡®çš„ `RuleTarget`

#### æ­¥éª¤4: æ›´æ–°ç»“æœå¤„ç†
- [ ] å®ç°æŒ‰è¡¨åˆ†ç»„çš„ç»“æœèšåˆ
- [ ] æ›´æ–°è¾“å‡ºæ ¼å¼ä»¥æ˜¾ç¤ºå¤šè¡¨ç»“æœ
- [ ] å¤„ç†è·¨è¡¨çš„é”™è¯¯ç»Ÿè®¡

#### æ­¥éª¤5: æ·»åŠ æµ‹è¯•è¦†ç›–
- [ ] åˆ›å»º `test_schema_command.py` æµ‹è¯•æ–‡ä»¶
- [ ] æµ‹è¯•å¤šè¡¨è§„åˆ™æ–‡ä»¶è§£æ
- [ ] æµ‹è¯•å¤šè¡¨è§„åˆ™åˆ†è§£
- [ ] æµ‹è¯•å¤šè¡¨ç»“æœè¾“å‡º
- [ ] ç¡®ä¿æµ‹è¯•è¦†ç›–ç‡ä¿æŒåœ¨80%ä»¥ä¸Š

### 6.2. é£é™©è¯„ä¼°ä¸ç¼“è§£

**é£é™©**: å¤šè¡¨æ”¯æŒå¯èƒ½å½±å“ç°æœ‰å•è¡¨åŠŸèƒ½
**ç¼“è§£**: ä¿æŒå‘åå…¼å®¹ï¼Œå•è¡¨è§„åˆ™æ–‡ä»¶ä»ç„¶æœ‰æ•ˆ

**é£é™©**: æ€§èƒ½å¯èƒ½ä¸‹é™ï¼ˆå¤šè¡¨éªŒè¯ï¼‰
**ç¼“è§£**: åˆ©ç”¨Coreå±‚çš„å¼‚æ­¥æ‰§è¡Œèƒ½åŠ›ï¼Œå¹¶è¡Œå¤„ç†å¤šè¡¨

**é£é™©**: é”™è¯¯å¤„ç†å¤æ‚åº¦å¢åŠ 
**ç¼“è§£**: å¤ç”¨ç°æœ‰çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼ŒæŒ‰è¡¨åˆ†ç»„é”™è¯¯ä¿¡æ¯
